



  Fakultät Elektrotechnik und Informatik     <Grafikdatei: C:/Users/fuer/Desktop/bachelor/BACHELOR_THESIS/text/thesis/images/HSB_Horizontal-Logo_Farbe_sRGB.png>  
                                                                                                                       






Entwicklung einer Domain-Specific-Language zur Risikoaggregation 
und Compliance-Reporting nach BCBS 239

Bachelorthesis zur Erlangung des akademischen Grades 
Bachelor of Science






  eingereicht von:     Felix Luther                      
                       Matrikelnummer: 5109429           
                       Studiengang: DS Informatik B.Sc.  
                                                         
  betreut durch:       Prof. Dr.-Ing. Heiko Mosemann     
                       Hochschule Bremen                 
                       M. Sc. Oliver Pohling             
                       Commerzbank AG                    
  Bremen, den                                            





 





Erklärung über das eigenständige Erstellen der Thesis

Hiermit versichere ich, dass ich die vorliegende Thesis 
selbstständig verfasst und keine anderen als die angegebenen 
Quellen und Hilfsmittel benutzt habe. Die Stellen der Thesis, die 
anderen Werken dem Wortlaut oder dem Sinn nach entnommen wurden, 
sind durch Angaben der Herkunft kenntlich gemacht.

Diese Erklärung erstreckt sich auch auf in der Thesis enthaltene 
Grafiken, Skizzen, bildliche Darstellungen sowie auf Quellen aus 
dem Internet. Die Thesis habe ich in gleicher oder ähnlicher Form 
auch auszugsweise noch nicht als Bestandteil einer Prüfungs- oder 
Studienleistung vorgelegt. 

Ich versichere, dass die eingereichte elektronische Version der 
Thesis vollständig mit der Druckversion übereinstimmt.






  Bremen, den                   
                  Felix Luther  
                  5109429       







 





Kurzfassung

Text.

Stichworte: DSL, textX, Jinja




Inhaltsverzeichnis

Kapitel 1 Einführung
1.1 Projektumfeld
1.2 Motivation
1.3 Zielsetzung
1.4 Aufbau der Thesis
Kapitel 2 Grundlagen
2.1 Domain-spezifische Sprachen
2.2 textX
2.3 Jinja
2.4 Python
Kapitel 3 Anforderungsanalyse
3.1 Kontext
3.2 Anforderungen
3.2.1 Nicht-funktionale Anforderungen
3.2.2 Funktionale Anforderungen
3.3 Verifikationsstrategie
Kapitel 4 Nutzwertanalyse
4.1 Kriterien
4.2 Möglichkeiten
4.2.1 Möglichkeit 1
4.2.2 Möglichkeit 2
4.2.3 Möglichkeit 3
4.3 Ergebnisse
4.4 Begründung der Auswahl
Kapitel 5 Entwurf
5.1 Vorführmodell
5.2 Architektur
TODO
5.2.1 Entwurf der DSL - „SIMQL“
TODO
5.2.2 DSL zu Generischen Artefakt Generator (Parser)
5.2.3 Generisches Artefakt zu Python Generator
5.3 Systemüberblick
TODO
Kapitel 6 Implementierung
6.1 Komponente 1: textX Syntax Datei
6.2 Komponente 2: DSL zu Generischen Artefakt Generator (Parser)
6.3 Komponente 3: Jinja-Template
6.4 Komponente 4: Generisches Artefakt zu Python Generator
Kapitel 7 Evaluation
7.1 
Kapitel 8 Resultate
Kapitel 9 Schlussbemerkung
9.1 Zusammenfassung
9.2 Ausblick
Anhang A Code von Komponente X
A.1 Anhang 1
Anhang B <Titel>
B.1 Code von X
Literaturverzeichnis









Abbildungsverzeichnis

✖ Abbildung 0.1: Die gegebene Hardware der GAU, von links: das NVIDIA Jetson Nano 2GB-Entwicklerkit (Quelle: [#Nvidia22])…



Tabellenverzeichnis

✖ Tabelle 0.1: Denavit Hartenberg Parameter 
Tabelle 3.1: Nicht-funktionale Anforderungen des Systems
Tabelle 4.1: Gewichtung der Kriterien
Tabelle 4.2: Punktwertkorridore auf einer 10er-Skala nach [#Kuehnapfel2014]
Tabelle 4.3: Bewertung der Kriterien
Tabelle 4.4: Gewichtete Kriterienwerte





Verzeichnis der Programmlistings

✖ Listing 0.1: foo





Einführung

Der erste Abschnitt des Kapitels beinhaltet das Projektumfeld der 
Thesis. Der zweite Abschnitt enthält die Motivation und im 
dritten Abschnitt wird die Zielsetzung geschildert. Abschließend 
wird der weitere Aufbau der Thesis dargestellt und kurz 
inhaltlich beschrieben.

1.1 Projektumfeld

Diese Bachelorthesis wird vom Autor im Rahmen seines Studiums 
beim Praxisunternehmen Commerzbank AG durchgeführt. Das Projekt 
findet im Bereich „Regulatory Operations, Advisory & Data“ statt, 
welche sich mit der Erstellung von meldepflichtigen Berichten 
beschäftigt statt. Die Abteilung, welche das Projekt betreut ist „
BT BI-Analytics Platform“, welche für den Aufbau und die folgende 
Betreuung einer neuen Plattform zur Berichtserstellung 
verantwortlich ist. Dieses Framework soll die Anforderungen von 
BCBS 239 (Standard zur Regelung der Risikoberichterstattung von 
Kreditinstituten) und die sich hierdurch ergebenden 
Data-Quality-Prozesse nachhaltig und konsequent umsetzen. Die 
Eingabedaten für dieses Framework kommen von sogenannten 
Sensoren, welche für die unterschiedlichen Dimensionen, wie 
Completeness oder Timeliness, der Data-Quality Kennzahlen 
erfassen. Meta-Sensoren sind spezialisierte Sensoren, dessen 
Aufgabe die Gruppierung von regulären Sensoren zu Sensorgruppen 
ist. Das Framework nutzt all diese gesammelten Daten, um Analysen 
zu fahren, Aktionen auszulösen und schließlich Berichte an die 
jeweiligen Stellen zu versenden.

1.2 Motivation

Für die Beschreibung der Sensoren soll eine Domain-Specific 
Language (DSL) entworfen werden. Mithilfe der DSL sollen 
verschiedene Aspekte der Sensoren beschrieben werden, für welche 
jeweils Sektionen vorgesehen sind. Diese sind z.B. die 
betrachteten (zu gruppierenden) Sensoren, die benötigten 
Parameter, die auszuführende Logik etc. Die DSL soll auch von 
Menschen ohne Hintergrund in der Informatik leicht verständlich 
und verwendbar sein. Mit der DSL sollen fachliche Zusammenhänge 
von Sensordaten beschrieben werden, keine komplexen Berechnungen. 
Mathematische Operationen, wie die Summierung oder auch die 
Berechnung der Standardabweichung sind im Sprachumfang enthalten. 
Die Logik soll sequentiell ausgeführt werden, mit der Möglichkeit 
Verzweigungen 1 in der Form von IF-Statements zu erstellen. 
Schleifen und Subroutinen sind nicht im Sprachumfang der DSL 
vorgesehen. Aus den mithilfe der DSL erstellten Definitionen 
sollen im Folgenden generische Artefakte generiert werden. Aus 
diesem generischen Artefakt sollen verschiedene Generatoren 
unterschiedliche Ergebnisse generieren. Vorgesehen sind 
Generatoren wie ein SQL-Generator, ein Dokumentationsgenerator, 
ein Simulationsgenerator und ggf. noch weitere. Im Rahmen der 
Bachelor-Thesis soll ein Generator erstellt werden, welcher ein 
lauffähiges Python-Skript generiert. Für die Erstellung des 
Python-Skripts ist die Verwendung von einem Template-Generator 
vorgesehen. Dieser sorgt dafür, dass der Code für den 
spezifischen Sensor in eine Vorlage (ein Template) eingefügt 
wird. Die Vorlage enthält Code, welcher bei jedem Sensor 
vorhanden sein soll, wie der Verbindungsaufbau zur Datenbank. 
Dieses Python-Skript kann dann im Folgenden im Framework 
aufgerufen werden und würde der Definition entsprechend arbeiten. 
Der Ansatz mit den Generatoren wird gewählt, um einen hohen Grad 
an Modularität zu erreichen. Diese Modularität wird angestrebt, 
damit die DSL zukünftig für alle Sensoren in diversen Systemen 
verwendbar ist.

1.3 Zielsetzung<sec:Zielsetzung>

Diese Thesis hat zum Thema, den Entwurf einer DSL zur 
Beschreibung von Meta-Sensoren.

Dabei fokussiert sich die Thesis auf die folgenden Ziele, zu 
welchen ein System entwickelt werden soll, dass

1. Die DSL wurde den Anforderungen entsprechend definiert

  a) Die Skripte für die DSL bestehen aus mehreren Sektionen

  b) Verzweigungen in der DSL sind möglich

  c) Logische Zusammenhänge zwischen Sensoren sind darstellbar

2. Programme in der DSL sind in ein generisches Artefakt 
  umwandelbar

3. Aus dem Artefakt lässt sich ein Python Skript generieren

4. Das Python Skript lässt sich erfolgreich ausführen 5. Die 
  Generatoren wurden getestet

1.4 Aufbau der Thesis

Im Folgenden werden zunächst in Kapitel [chap:Grundlagen] für das 
Nachvollziehen notwendige Grundlagen dieser Bachelorthesis 
vorgestellt.



Grundlagen<chap:Grundlagen>

In diesem Kapitel werden die Grundlagen für diese Thesis 
erläutert.

2.1 Domain-spezifische Sprachen

Domain-spezifische Sprachen sind Computersprachen, welche für 
einen bestimmten Teilbereich/ eine bestimmte Domäne erstellt 
wurden. Somit ist ihr Sprachumfang oft eingeschränkt im Vergleich 
zu herkömmlichen Programmiersprachen, auch GPLs. Dieses steht für 
General-Purpose Lanauges und Beispiele hierfür sind z.B. Java, 
Python und C++. Während alle GPLs Turing-Vollständig sind, ist 
dieses für DSLs oft nicht der Fall. Die in denen verwendete 
Syntax und vorhandenen Keywords sind dementsprechend auch an der 
Domäne orientiert und benötigen in vielen Fällen 
Hintergrundwissen in der Domäne, für welche sie erstellt wurden. 
DSLs können zudem in interne und externe eingeteit werden. 
Interne DSLs, auch embedded DSLs genannt sind wie der zweite 
Namen suggeriert in Programmiersprachen vorhanden und dienen zur 
Erleichterung der Entwicklung in einer bestimmten Domäne, ein 
Beispiel hierfür ist ist LINQ, welche das intuitive Erstellen von 
Database-Queries im .NET Framework ermöglicht. Sie werden mit dem 
gleichen Compiler oder Interpreter wie die Sprache in welchem Sie 
eingesetzt werden verarbeitet. Im Gegensatz hierzu stehen die 
external DSLs, welche mithilfe von deren eigenen 
Compiler/Interpreter entsprechend kompiliert oder interpretiert 
werden. Ein Beispiel für externe DSLs ist z.B. das sehr beliebte 
CSS (Cascading Style Sheets), mit welchem das Aussehen von 
Webseiten beschrieben wird.

[1]

2.2 textX

textX ist eine Meta-Sprcache, mit welcher sich Domain-spezifische 
Sprachen spezifizieren lassen und als Python Bibliothek verfügbar 
ist. In einer Syntax-Datei wird mithilfe dieser Meta-Sprache die 
Syntax von der zu erstellenden DSL mithilfe von RegEx als Regeln 
zu beschrieben. textX selber bietet auch eine Anzahl an 
eingebauten Datentypen, welches bereits vorhandene RegEx-Muster 
sind. Diese können in Kombination mit eigenen Mustern verwendet 
werden, um komplizierte Sytaxstrukturen zu definieren. Diese 
Datei wird später von textX verwendet, um die Syntax der 
zukünftigen DSL-Skripte zu verifizieren. In Python kann der 
Entwickler sich mithilfe dieser Datei ein Metamodell, in Form 
eines Python-Objektes erhalten. Das Meta-Model enthält für jede 
in der Sytax-Datei definierten Regel eine Python-Klasse. Das 
Meta-Model enthält die Logik zum Parsen von Eingabe-String der 
spezifizierten DSL. Dementsprechend kann dieses folgend verwendet 
werden, um die DSL-Skripte zu parsen, um aus diesen Modelle zu 
generieren. Diese Modelle sind Python Objekte, die Zugriff auf 
jeweiligen in der Syntax-Datei beschrieben Komponenten zu 
gewähren. Der größte Teil der Arbeit, um die eigene DSL in Python 
verständlich zu machen ist somit die Erstellung der Syntax-Datei, 
während der Python Teil mit Abstand weniger Aufwand benötigt.

textX unterstützt zudem mit deren CLI (Command-Line Interface) 
die Erstellung und Verwendung von sogenannten Generatoren. Die 
Aufgabe der Generatoren ist die Verarbeitung von Eingabedaten 
eines bestimmten Formats und die folgende Generierung von einem 
Objekt in einem anderen Format. Ein Beispiel wäre die Umwandlung 
von einem Skript einer selbst definierten DSL in ein lauffähiges 
Programm. Dieses Generaten-Framework bietet zudem in Python 
Hilfsfunktionen, welche die Zusammenarbeit zwischen textX und 
Jinja erleichtern.

http://textx.github.io/textX/3.1/

2.3 Jinja

Jinja eine Template-Engine, welche in Form einer 
Python-Bibliothek verfügbar ist. Jinja verwendet Schablonen, 
sogenannte Templates, um Text, oder auch Code zu generieren. In 
diesen Templates ist neben dem Text, welcher immer eingefügt 
werden soll, auch die Erstellung von Jinja-spezifischen 
Bereichen, mithilfe von speziellen Platzhaltern möglich. Diese 
Platzhalter sind in der Syntax ähnlich zu der von Python. Mit 
Jinja lässt sich somit z.B. unterschiedlicher Code injektieren, 
abhängig von den Eingabedaten. Die Definition von Schleifen ist 
zudem auch möglich. Jinja bieten zudem auch eine vielzahl an 
fortgeschrittenen Features wie der Vererbung von Template, oder 
auch die Auswahl der Kompilierungsstrategie. Somit bleibt dem 
Entwickler die Wahl, ob die Templates in echtzeit (just-in-time: 
JIT), oder vorher (ahead-of-time) kompiliert werden sollen. Jinja 
ist zudem auch leicht erweiterbar in vielen seiner Aspekte, 
welches gut bei der Arbeit mit der Bibliothek unterstützen kann.

https://jinja.palletsprojects.com/en/3.1.x/intro/

2.4 Python

Python ist eine General-purpose langauge (GPL), welche stark 
verbreitet ist. Laut der Stack Overflow Developer Survey 2023, 
welche im Mai 2023 durchgeführt wurde, befindet sie sich zzt. an 
dritter Stelle der beliebtesten Technologien unter 
Software-Entwicklern. Sie wird oft verwendet für ihre intiutive 
Syntax und ihre Plattformunabhängigkeit. Sie erreicht diese 
Unabhängigkeit dadurch, dadurch, dass sie interpretiert wird. 
Python unterstützt zudem die objektorienterte Programmierung und 
und findet auch viel Anwendung als Skriptsprache.


https://survey.stackoverflow.co/2023/#most-popular-technologies-language

Anforderungsanalyse<chap:Anforderungsanalyse>

Im Folgenden wird der für diese Arbeit relevante Kontext des nach 
der Zielsetzung (siehe [sec:Zielsetzung]) zu entwickelnden 
Systems beschrieben. Anschließend werden geeignete Anforderungen 
spezifiziert und eine Verifikationsstrategie festgelegt.

3.1 Kontext

3.2 Anforderungen<sec:Anforderungen>

3.2.1 Nicht-funktionale Anforderungen<subsec:Nicht-funktionale-Anforderungen>

[Gleitobjekt Tabelle:
[Tabelle 3.1: 
Nicht-funktionale Anforderungen des Systems
]


------------------------------------------------
  ID    Anforderung      Verifikations-methode  
------------------------------------------------
------------------------------------------------
  N1    Anforderung 1    ?                      
------------------------------------------------
  N2    Anforderung 2    ?                      
------------------------------------------------
  N3    Anforderung 3    ?                      
------------------------------------------------

]

3.2.2 Funktionale Anforderungen<subsec:Funktionale-Anforderungen>

3.3 Verifikationsstrategie<sec:Verifikationsstrategie>

Nutzwertanalyse<chap:Bewertung-von-Simulationsplattfo>

Text.

4.1 Kriterien

Im Folgenden werden die Kriterien für das Vergleichen und 
Bewerten der verschiedenen Lösungsmöglichkeiten definiert.

• Kriterium 1:

• Kriterium 2: 

• Kriterium 3: 

Zusammenfassend werden die Kriterien in der folgenden Tabelle [tab:Gewichtung-der-Kriterien-1]
 mit der erfassten Gewichtung aufgeführt, welche für die 
Evaluation relevant ist.

[Gleitobjekt Tabelle:
[Tabelle 4.1: 
Gewichtung der Kriterien<tab:Gewichtung-der-Kriterien-1>
]


-----------------------------------------
  Kriterium      Kurz       Gewicht (%)  
-----------------------------------------
-----------------------------------------
  Kriterium 1    Krit. A    ?            
-----------------------------------------
  Kriterium 2    Krit. B    ?            
-----------------------------------------
  Kriterium 3    Krit. C    ?            
-----------------------------------------
  Summe                     100          
-----------------------------------------

]

4.2 Möglichkeiten

4.2.1 Möglichkeit 1

4.2.2 Möglichkeit 2

4.2.3 Möglichkeit 3

4.3 Ergebnisse

Zur Kriterienbewertung der möglichen Simulationsplattformen wird 
die Punktwertkorridore aus Tabelle [tab:Punktwertekorridore-auf-einer]
 herangezogen. Die ungewichteten und gewichteten 
Bewertungsergebnisse werden in den Tabellen [tab:Gewichtung-der-Kriterien-2]
 und [tab:Gewichtung-der-Kriterien] aufgelistet.

[Gleitobjekt Tabelle:
[Tabelle 4.2: 
Punktwertkorridore auf einer 10er-Skala nach [#Kuehnapfel2014]<tab:Punktwertekorridore-auf-einer>

]


-------------------------------------------------------------------------------------------------------
  Punkte    Beschreibung                                                                               
-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
    0       Kriterium ist nicht erfüllt/nicht nützlich                                                 
-------------------------------------------------------------------------------------------------------
   1-3      Kriterium ist unzureichend und nur mit erheblichen Mängeln 
 erfüllt/nur bedingt nützlich  
-------------------------------------------------------------------------------------------------------
   4-6      Kriterium ist hinreichend, aber mit Mängeln erfüllt/nützlich                               
-------------------------------------------------------------------------------------------------------
   7-9      Kriterium ist in gutem Umfang erfüllt/sehr nützlich                                        
-------------------------------------------------------------------------------------------------------
    10      Kriterium ist in sehr gutem Umfang erfüllt/außerordentlich 
nützlich                       
-------------------------------------------------------------------------------------------------------

] 

[Gleitobjekt Tabelle:
[Tabelle 4.3: 
Bewertung der Kriterien<tab:Gewichtung-der-Kriterien-2>
]


--------------------------------------------------------
       Möglichkeit 1    Möglichkeit 2    Möglichkeit 3  
--------------------------------------------------------
--------------------------------------------------------
  A          ?                ?                ?        
--------------------------------------------------------
  B          ?                ?                ?        
--------------------------------------------------------
  C          ?                ?                ?        
--------------------------------------------------------

]

[Gleitobjekt Tabelle:
[Tabelle 4.4: 
Gewichtete Kriterienwerte<tab:Gewichtung-der-Kriterien>
]


-----------------------------------------------------------------------
            Möglichkeit 1        Möglichkeit 2        Möglichkeit 3    
-----------------------------------------------------------------------
          B.    KW             B.    KW             B.    KW           
-----------------------------------------------------------------------
-----------------------------------------------------------------------
  A       ?     ?              ?     ?              ?     ?            
-----------------------------------------------------------------------
  B       ?     ?              ?     ?              ?     ?            
-----------------------------------------------------------------------
  C       ?     ?              ?     ?              ?     ?            
-----------------------------------------------------------------------
  \sum    ?     ?              ?     ?              ?     ?            
-----------------------------------------------------------------------

]

4.4 Begründung der Auswahl

Nach der Kriterienbewertung (siehe [tab:Gewichtung-der-Kriterien-2]
 und [tab:Gewichtung-der-Kriterien]) erbrachte... Text.

Entwurf<chap:Entwurf>

In diesem Kapitel wird der Entwurf des Systems, auf welchem die 
Implementierung basieren wird, erarbeitet...

5.1 Vorführmodell

5.2 Architektur

Ingesamt wird das System aus zwei Komponenten bestehen, welche 
aufeinander aufbauen. Die erste Komponente ist für das Einlesen 
der DSL Skripte verantwortlich und verwandelt diese in ein 
generisches Artefakt. Die zweite Komptonente ist dafür zuständig 
dieses generische Artefakt in ein lauffähiges Python Skript 
umzuwandeln. „Textx“ unterstützt zudem die Einbindung solcher 
Komponenten/Skripte als Generatoren, welche dann mithilfe des „
textx“ CLI-Tool ansprechbar sind. 

  TODO

Ob diese Einbindung auch für die zweite Komponenten anwendbar 
ist, muss noch festgestellt werden, falls dieses der Fall ist, 
soll davon Gebrauch gemacht werden. 

5.2.1 Entwurf der DSL - „SIMQL“

Es ist vorgesehen, dass SIMQL aus mehren Sektionen besteht. 
Dieses soll die Skripte besser strukturieren und leichter 
verständlich machen. Eine Sektion beginnt mit „section [[name]]:“ 
und endet mit „end“. Kommentare sollen sowohl am Anfang des 
Skripts in Form eines Multi-Line Comment möglich sein, als auch 
am Ende jeder Zeile. Die erste Sektion ist heißt „sensors“. Bei 
dieser werden die Sensorobjekte, auf welche in der Zukunft 
zugegriffen wird, zu lokalen Variablen zugewiesen. Die Nächste 
Sektion ist die „data“ Sektion, in welcher „load data“ Statements 
enthalten sind. Die Aufgabe dieser Statements ist das Laden Holen 
der Daten, welche zu den vorher definierten Sensor-Variablen 
gehören. Hiernach folgen eine beliebige Anzahl an „compute data“ 
Statements. Diese Statements machen erneut gebrauch von den 
vorher definierten Variablen und macht nun Nutzen von den in der 
vorherigen Sektion eingelesenen Daten. Die Statements bestehen 
aus zwei Argumenten, das erste Argument ist eine Liste an 
Objekten (Variablen), mit welchen gearbeitet werden soll, während 
das zweite Argument die mathematische Operation angibt, welche 
auf diese Objekte ausgeführt werden soll. Neben den Variablen ist 
in der Liste auch die Angabe von „self“ Möglich, welches somit 
eine Operation auf die Daten des Metasensors selber darstellt. 
Ein Skript endet mit einem „save data“ Statement, welches nur 
über ein Argument verfügt, welches der Timestamp ist, unter 
welchem Daten abgespeichert werden sollen. Die Aufgabe des 
Statements ist somit das Speichern und Absenden der bestimmten 
Daten.

  TODO

self Bedeutung weiter erforschen und erfragen

5.2.2 DSL zu Generischen Artefakt Generator (Parser)

Die Aufgabe dieser Komponente ist das parsen der DSL-Skripte und 
die folgende Ausgabe eines generischen Artefakts. Die Komponente 
wird über die Kommandozeile aufgerufen werden, eine GUI ist nicht 
vorgesehen. Als Argumente werden dem Skript der Dateipfad zum 
DSL-Skript, als auch ein Pfad für die Ausgabe des Artefakts 
mitgegeben. Mithilfe von textX wird das DSL-Skript unter 
Verwendung der Syntax-Datei in ein Python Objekt umgewandlt. 
Dieses Objekt wird im folgenden dafür verwendet um die 
Komponenten des Skript zu überprüfen auf deren Logik. Die meiste 
Überprüfungslogik beschäftigt sich mit der Logic Sektion der 
Skripte. Nachdem der Inahlt des Skrips auf Korrektheit überprüft 
wurde, beginnt die Generierung des generischen Artefakts. Für das 
Artefakt wird das JSON-Format als Dateiformat gewählt. In diesem 
werden die relevanten Bestandteile der Skripte strukturiert 
abgebildet. JSON wurde als Format hierfür gewhält, da es 
menschlich gut verständlich, leicht erweiterbar und es auch gute 
Unterstützung in der Python-Standartbibliotek für das Format 
gibt. Im letzten Schritt wird das Artefakt als Datei auf die 
Festplatte geschrieben.

5.2.3 Generisches Artefakt zu Python Generator

Die Aufgabe dieses Generators ist die Generierung von einem 
lauffähigen Python-Skript aus einem generischen Artefakt im 
JSON-Format. Die Komponente wird über die Kommandozeile 
aufgerufen werden, eine GUI ist nicht vorgesehen. Als Argumente 
werden dem Skript der Dateipfad zum generischen Artefakt, als 
auch ein Pfad für die Ausgabe des Python-Skripts mitgegeben. Die 
Erstellung der Python-Skripte geschieht mithilfe von Jinja, einem 
Template-Generators. Der Generator macht somit neben der 
Eingabe-Datei noch nutzen von einer anderen Datei, dem Template. 
Das Template enthält sowohl den Python-Code, welcher in jedem 
Python-Skript dieser Natur notwendig ist, als auch Text in der 
Jinja-spezifischen Syntax, welcher später für die Injektion 
verwendet wird. Mithilfe von Injektion werden in das Template 
abhängig von dem inhalt des generischen Artefakts 
unterschiedlicher Code eingefügt, um die gewollte Logik korrekt 
abzubilden.

5.3 Systemüberblick<sec:Systemüberblick>

  TODO

Eine Graphik, welche dieses verbildlicht ist vorgesehen.

Implementierung<chap:Implementierung>

Text.

6.1 Komponente 1: textX Syntax Datei

6.2 Komponente 2: DSL zu Generischen Artefakt Generator (Parser)

6.3 Komponente 3: Jinja-Template

6.4 Komponente 4: Generisches Artefakt zu Python Generator

Evaluation<chap:Evaluation>

Text.

7.1 

Resultate<chap:Resultate>

Text.

Schlussbemerkung<chap:Schlussbemerkung>

In diesem Kapitel wird der Inhalt dieser Arbeit zusammengefasst 
und ein Ausblick darüber gegeben, wie die Erkenntnisse und 
Resultate dieser Arbeit in der Zukunft vonnutzen sein können.



9.1 Zusammenfassung

Diese Bachelorthesis ist der Forschungsfrage nachgegangen, wie 
eine Domain-spezifische Sprache zur Definition von Meta-Sensoren 
umzusetzten ist.
Abschließend lässt sich sagen, dass.....

9.2 Ausblick

Text.

Code von Komponente X<chap:ROS-Beispiel>

A.1 Anhang 1

<Titel>

B.1 Code von X








[ECSS: European Cooperation for Space Standardization][XML: Extensible Markup Language]
[URDF: Unified Robot Description Format]

[LaTeX-Befehl: printnomenclature]





Literaturverzeichnis

[1] Markus Voelter, Sebastian Benz, Christian Dietrich, Birgit Engelmann, Mats Helander, Lennart Kats, Eelco Visser, and Guido Wach…, "DSL Engineering Designing, Implementing and Using Domain-Speciﬁc Languages" (2010).




